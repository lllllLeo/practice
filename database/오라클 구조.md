오라클 구조
===

## [1. I/O와 디스크의 관계](#i/o와-디스크의-관계)
## [2. 오라클의 여러 프로세스](#오라클의-여러-프로세스)
## [3. 캐시와 공유 메모리](#캐시와-공유-메모리)
## [4. SQL문 분석과 공유 풀](#sql문-분석과-공유-풀)
## [5. 오라클의 기동과 정지](#오라클의-기동과-정지)
## [6. 커넥션과 서버스로세스의 생성](#커넥션과-서버스로세스의-생성)
## [7. 오라클의 데이터 구조](#오라클의-데이터-구조)
## [8. 오라클의 대기와 락](#오라클의-대기와-락)
## [9. 리두와 언두의 동작](#리두와-언두의-동작)
## [10. 백업/복구의 아키텍처와 동작](#백업/복구의-아키텍처와-동작)

* * *
# 1. I/O와 디스크의 관계
## 디스크의 동작
- `시크(seek)`
  - 데이터를 읽기 또는 기록하기 위해서 원하는 트랙을 찾는 행위
- `시퀀셜(sequential) 액세스`⇔`랜덤 액세스`
  - 순차적으로 시작점에서부터 마지막까지 중간 부분을 빠트리지 않고 전부 액세스(읽기/쓰기).
  - 풀 스캔할 때 메모리에 데이터가 없다면 시퀀셜 액세스가 발생
  - `db file scattered read` 라고 표시
    - 시퀀셜하게 읽어 오는 것이므로 여러 개의 블록을 읽어온다. 오라클은 데이터를 블록 단위로 메모리에 배치한다. 즉, 여러 개의 블록이 연속하지 않은 곳에 놓인다.

-> 시간이 오래걸려서 성능이 느려짐. 그래서 인덱스라는 발상이 나옴
- `인덱스`
  - 데이터베이스의 인덱스에서는 색인할 때 사용하는 키 값(SQL문의 where절에 적는 조건의 값)과 그 키가 존재하고 있는 위치가 기록되어 있음
- `랜덤 액세스`
  - 헤드를 움직여 가면서 띄엄띄엄 액세스(읽기/쓰기)
  - `db file sequential read` 라고 표시
  - 단일 블록을 읽어 오므로 읽어 온 데이터는 당연히 메모리에서 연속됨. 오라클의 메모리에서 연속되어 있음

# 2. 오라클의 여러 프로세스
### 데이터베이스
  - 여러 사용자나 프로그램이 데이터베이스의 데이터를 공유
### 프로세스
  - 실행 상태에 있는 프로그램
  - 메모리나 자원을 가지고 있다.
### 스레드
  - 프로세스 내에 존재하는 실행 단위
  - 하나의 프로세스 안에서 처리를 병렬로 하고 싶을 때 사용
  - 부하가 적지만 메모리를 스레드끼리 공유하기 때문에 주의해서 사용    
-> 프로세스와 스레드의 가장 차이점은 **부하의 크기와 메모리 공유 여부**

### 오라클이 여러 개의 프로세스로 구성된 이유
- 다중 처리를 하고 싶기 때문이다. SQL처리는 길게는 몇 시간이 걸리는 경우가 있어서 그동안 다른 사용자를 기다리게 할 수 없다. 디스크는 메모리 액세스에 비해서 속도가 느리다. 이런 I/O가 반복되고 있는 동안 CPU와 같은 자원을 쉬게 하는 것을 매우 아깝기 때문에 가능하다면 다른 SQL 처리를 해야 한다. 

- 서버 프로세스
  - SQL문을 처리하는 프로세스
  - 오라클 클라이언트에 직접 서비스하는 프로세스
  - 실제 처리를 하는 것은 **서버 프로세스**이기 떄문에 튜닝할 때 **서버 프로세스**를 보면 됨 (백그라운드 프로세스는 서버 프로세스를 방해하지 않는 한 볼 필요X)
- 백그라운드 프로세스
  - 주로 서버 프로세스를 도와주는 프로세스로 구성
  - 오라클 클라이언트에 직접 서비스하지 않는 프로세스

# 3. 캐시와 공유 메모리
### 캐시 메모리
- 캐시의 목적은 빈번하게 사용하는 데이터를 매번 디스크에서 꺼내 오지 않고 캐시라고 불리는 메모리에 둠으로써 빠르게 사용할 수 있도록 하는 것

### 데이터는 블록 단위로 관리
- 오라클은 '블록'이라고 하는 단위로 데이터를 관리 (I/O, 버퍼 캐시도 블록 단위)

### 프로세스는 캐시를 공유한다
- 기본적으로 다른 프로세스의 메모리를 보는 것은 불가능하지만 캐시는 '**공유 메모리**'로 어떠한 오라클 프로세스라도 볼 수 있는 메모리를 활용한다. 즉 다른 프로세스에서도 자신의 메모리 영역에서 기록한 데이터를 볼 수 있다
- 베타 제어 (exclusive control)로 공유 메모리의 접근에 락을 걸어서 제어를 할 수 있음
- 공유 메모리 SGA(System Global Area)
- 공유하지 않는 메모리 일부 PGA(Program Global Area)

### 버퍼 캐시를 정리하는 LRU 알고리즘
- LRU(Least Recently Used) 알고리즘
  - 최근에 사용하지 않은 데이터부터 캐시 아웃
- 오라클의 서버 프로세스는 변경한 데이터도 캐시에 둔다. (서버 프로세스는 디스크에서 읽어오기만함. 기록은 백그라운드 프로세스가 함) DBWR 가 캐시에서 버려지기 전에 디스크에 정기적으로 기록을 해둠

# 4. SQL문 분석과 공유 풀

프로그래밍 언어와 SQL문의 가장 큰 차이는 SQL문은 '처리 방법(절차)'을 기술하지 않는다.  
`SELECT A FROM B WHERE C = 1` 을 보면 어디에도 '인덱스를 사용해서'나 '풀 스캔을 해라'와 같은 처리 방법을 기술하지 않았다. 하지만 RDBMS에서는 **옵티마이저(파서)**가 SQL문을 분석하고 '실행 계획(plan)'이라고 하는 처리 방법을 생성해 준다.

### 오라클에서의 `분석`이란?
 - SQL문을 분석하고 어떤 요소(테이블이나 컬럼 등)로 구성되어 있는지를 조사하고 어떤 식으로 처리할지까지 알고리즘에 기반을 둔 처리하는 것을 가리킴.  

### 분석에 사용되는 오라클의 알고리즘  
- ~~`규칙 기반(rule base)`~~ : 오라클 10g부터 규칙 기반을 지원하지 않음.  
- `비용 기반(cost base)` : '처리 시간이나 I/O 횟수가 가장 작다고 생각되는 처리 방법이 최상이다'라는 알고리즘

오라클에서는 처리 시간이나 I/O 횟수를 예측하기 위해서 '비용'이라고 불리는 수치를 이용한다. 

`비용` : 처리에 필요하다고 생각되는 시간 또는 사용량  
  - '통계 정보'라 불리는 기초 수치를 기반으로 계산    
  
`통계 정보` : 비용을 계산하기 위한 기초적인 정보들이 들어있음. (이 테이블에는 데이터가 몇 건이나 존재하며, 데이터양은 어느 정도이고, 컬럼의 최댓값, 최솟값은 어떠며 이 테이블의 인덱스는 ~'와 같은 테이블이나 인덱스에 관한 기초 수치.  
  - 오라클에서는 `통계 정보`를 '통계 수집(dbms_stats)'이라고 불리는 작업을 통해 얻을 수 있다.(오라클 10g부터 오라클이 자동으로 수행)
---
## 공유풀의 동작과 구조
## 공유풀 
- SQL문을 분석하는데 드는 CPU 자원이 소모되기 때문에 이미 사용한 실행계획을 재사용하기 위함
- 공유 풀은 실행 계획을 재이용하고 분석 작업을 줄이기 위한 존재 -> 잘 이용하면 CPU자원 절약
- 프로세스 간에 공유하지 않으면 안 되기 때문에 버퍼 캐시와 마찬가지로 **공유 메모리**에 존재함
  - 대부분 공유 메모리에 버퍼 캐시가 많이 차지하고 남은 일부가 공유 풀로 사용된다. 공유 풀은 **라이브러리 캐시, 딕셔너리 캐시**로 나눠진다.
    - 라이브러리 캐시 (Library Cache)  
    공유 풀의 중요한 역할인 **실행 계획** 등이 존재하며 SQL 정보의 캐시는 여기에서 수행한다.
    - 딕셔너리 캐시 (Dictionary Cache)  
    통계 정보의 캐시 등 주로 SQL의 실행에 필요한 메타 정보를 보관하고 있다.

## 동일한 SQL문 판단 기준
- 오라클은 해시 알고리즘을 사용해서 SQL문마다 ID를 생성
- 해시 함수에서는 대/소문자 구분한다.
  >SELECT id, email FROM user WHERE id = 1;  
  >Select id, email FROM user WHERE id = 2;  
  -> 대/소문자 다름. 서로 다른 SQL문으로 인식
- 검색 조건의 값이 다른 SQL문은 바인드 변수를 사용하면 같은 SQL문으로 판단
  - `바인드 변수` : 프로그램의 변수를 SQL문에서 사용하는 기능
  >SELECT id, email FROM user WHERE id = :A;  
  >SELECT id, email FROM user WHERE id = :A;  
  ->:A라는 변수에 값 1,2를 넣고 실행을 하면 둘은 같은 작업을 수행한다. 즉 같은 SQL문이라고 인식하기 때문에 캐시에 남아있으면 분석 작업을 수행하지 않는다.

## 분석(Parse)
- 하드 파스(hard parse)
  - 공유 풀에 실행 계획이 없으므로 실행 계획을 생성하는 경우
- 소프트 파스(soft parse)
  - 공유 풀에 캐시되어 있는 실행계획이 존재하므로 재이용하는 경우

## 요약
- SQL문에는 처리 방법이 적혀 있지 않기 때문에 오라클이 처리 방법(실행 계획)을 생성할 필요가 있다.
- 실행 계획의 좋고 나쁨에 따라 성능이 크게 변한다
- 실행 계획을 생성하기 위해서는 많은 양의 CPU를 사용하기 때문에 공유 풀(라이브러리 캐시)에 실행 계획을 캐시해서 재활용한다.


# 5. 오라클의 기동과 정지
(Windows용과 UNIX용 오라클의 내부 구조는 동일하지만 Windows용 오라클은 멀티스레드 구조, UNIX용 오라클은 멀티프로세스 구조이다. 아래 설명은 UNIX용 환경임)

## 오라클 기동 4가지 상태
- OPEN
  - 데이터 처리를 할 수 있는 상태.
  - SQL을 처리할 수 있는 상태
- MOUNT
  - 데이터 파일 등에 접근할 수 있는 상태 (컨트롤 파일을 읽은 상태)
- NOMOUNT
  - 백그라운드 프로세스와 공유 메모리가 존재하는 상태
- SHUTDOWN
  - 정지상태  

### 수행하는 작업  
`SHUTDOWN -> NOMOUNT -> MOUNT -> OPEN `  
>          1          2        3    

1. 초기화 파라미터를 읽어 와서 백그라운드 프로세스를 기동시키고 공유 메모리를 할당한다.
1. 컨트롤 파일을 읽어 온다.
1. 데이터 파일에 대한 체크 등을 한다.

- 컨트롤 파일 : 데이터베이스의 구성 정보가 적혀 있는 파일(데이터베이스의 파일(데이터 파일이나 redo log 파일) 경로 등)을 알 수 있다.  
- 데이터 파일 : 실제 데이터가 보관된 파일 (언두, )
- redo log 파일 : 데이터의 변경 이력을 보관하는 파일  

### 인스턴스 (instance)
 - 오라클에서는 관리하기 위한 단위로 '인스턴스'라는 용어를 사용 -> **데이터베이스를 관리하는 것**
 - **'백그라운드 프로세스 + 공유 메모리'**
 - 'NOMOUNT' 상태가 인스턴스가 기동한 상태

 ## 기동 처리의 흐름
 1. 기동 정지 상태에서 NOMOUNT로 전환  
 sqlplus에 관리자 계정으로 접속 후 
 > \> startup nomount  

-> 정지 상태에서 'NOMOUNT'상태로 변경한다. 이 명령어는 내부적으로 환경 변수 ORACLE_HOME과 ORACLE_SID를 토대로 초기화 파라미터 파일을 찾아서 읽는다. 읽어 온 파라미터를 토대로 공유 메모리를 확보하고 백그라운드 프로세스를 생성한다.

2. NOMOUNT로부터 MOUNT로 전환  

> \> alter database mount

-> 초기화 파라미터에 기술된 컨트롤 파일의 경로를 사용해 컨트롤 파일을 열어 내용을 읽어 온다. -> redo log 파일이나 데이터 파일의 위치를 파악할 수 있음. 이때, 위치를 알아내는 것 뿐이므로 파일이 없다고 해도 이 시점에서는 에러가 발생하지 않는다.

3. MOUNT에서 OPEN으로 전환

> \> alter database open

-> 명령어 내부에서는 데이터 파일을 열어서 간단한 점검 (오라클이 내부적으로 사용하는 데이터들의 앞뒤가 맞는 상황인지 등)을 하거나, 백그라운드 프로세스를 기동함. 마무리가 완료되면 데이터 파일을 읽고 기록할 수 있는 상태.   
즉, OPEN 상태가 된다.(SQL을 실행할 수 있는 상태)

위는 기동을 자세하게 보여주기 위해 3단계로 명령어를 작성하였지만  

정지 상태에서
> \> startup  

을 입력하면 위와 같이 세 가지의 명령어를 수행하고 OPEN 상태가 된다.

## 기동 종료
> \> shutdown
- 접속한 모든 오라클 클아이언트의 접속이 종료한 후에 기동 작업의 역순으로 데이터베이스를 단은 후에 인스턴스를 종료한다.  
- **인스턴스의 정지**란 공유 메모리를 반환하고 백그라운드 프로세스를 정지하는 것이다.
- 기동 종료시 추가 작업  
  - 버퍼 캐시에 분산된 데이터를 정리하는 것
  - 성능상의 이유로 변경된 데이터를 즉시 데이터 파일에 보관하지 않는다. 기록하지 않은 변경된 데이터를 데이터베이스를 닫는 작업의 일환으로 데이터 파일에 기록하는 것이 이 작업이다.  

### 인스턴스 복구(instance recovery)
- 기동이 종료되고 변경된 데이터를 기록하지 않고 종료하면 다음 기동 시에 데이터를 복구함. (오라클이 알아서 수행)
- 데이터 파일에 기록되지 않은 데이터는 redo log 파일의 데이터를 사용해서 복구 (오래된 데이터 파일의 내용 -> 최신 데이터 파일의 내용으로 교체)

# 6. 커넥션과 서버스로세스의 생성
(Windows용과 UNIX용 오라클의 내부 구조는 동일하지만 Windows용 오라클은 멀티스레드 구조, UNIX용 오라클은 멀티프로세스 구조이다. 아래 설명은 UNIX용 환경임)

- 애플리케이션에서의 커넥션을 최적화하는 것만으로도 데이터베이스의 성능을 더욱 끌어올릴 수 있다.
- 커넥션을 알게 됨으로써 애플리케이션에서 피해야만 하는 코딩 방식을 이해하는데에도 도움이 됨.


## 오라클의 커넥션 동작
- 오라클은 네트워크 통신 수단으로 대부분 TCP/IP 소켓을 사용함
- `리스너 (Listener)` : 오라클에서 수신을 기다리는 프로세스(서버 프로세스 X)
- 리스너로 커넥션을 하는 프로세스는 **업무 애플리케이션의 프로세스**임

### 커넥션 처리 1 : 리스너 기동
- listener의 설정 후 lsnrctl 도구를 이용해 기동할 때 listener가 안내해야하는 데이터베이스를 아는 방법으로는 `1. listener.ora 파일에 기록되어있는 것을 읽거나` `2. 자동으로 등록하는 방법`이 있다.
- `listener.ora` : 리스너를 위한 설정파일이다. 리스너의 포트 번호가 기록되어 있음

### 커넥션 처리 2 : 애플리케이션에서의 커넥션
- 업무 애플리케이션 안에서 커넥션 명령이 실행되거나 Sqlplus에서 connect 명령어를 받으면 **커넥션을 수행**한다.
- 커넥션에 필요한 정보인 '**커넥션 디스크립터(connection descripor)**'를 오라클 클라이언트에 전달한다. 하지만 커넥션을 하기 위해서 매번 기술할 수 없으므로 커넥션 디스크립터를 **tnsnames.ora**에 작성 후 커넥션 식별자(별칭)을 붙인다.
  - `커넥션 디스크립터` : 주소, 포트, 서비스 이름 등 과 같은 소켓을 만드는 데 (,접속에) 필요한 정보들과 리스너에게 전달하기 위한 정보가 작성되어 있음.  
  
  - `tnsnames.ora` : 커넥션 디스크립터와 별칭이 작성되어 있다. 이 파일을 이용해서 오라클 클라이언트는 리스너와의 사이에 소켓을 생성과 통신함.

### 커넥션 처리 3 : 서버 프로세스의 생성
- 서버 프로세스의 생성과 소켓은 인계받음
- 소켓을 생성하고 서버 프로세스를 생성한다.
  - 리스너가 SQL과 같은 처리를 하면 다른 처리를 할 수 없으므로 서버 프로세스를 생성한 후 처리를 인계한다.
  - 서버 프로세스의 생성은 매우 큰 작업이다. 먼저 OS 상에서 프로세스를 생성해야하고 서버 프로세스가 공유 메모리를 사용 할 수 있도록 해야하고 또한 서버 프로세스용 메모리도 확보해야 한다. 이외에도 데이터베이스 내부의 처리도 여러개 있음. 그래서 아래 코드와 같이 서버 프로세스의 생성이 필요한 물리 커넥션을 만들고 종료하기를 반복하는 형태는 안하는게 좋다.
  ```java
  Connection conn = ods.getConnection();
  ...executeQuerty("SELECT ...")'
  conn.close();

  (...)

  Connection conn = ods.getConnection();
  ...executeQuerty("INSERT ...")'
  conn.close();
  ```
  - -> 커넥션 풀, 오라클의 '공유 서버 구성'을 사용하면 된다.
  - `커넥션 풀` : 서버 프로세스를 몇 개를 풀로 만들어 두고 여러 애플리케이션이 자신이 쓰고 싶을 때만 풀에서 하나를 꺼내 사용하는 방법 (클라이언트가 커넥션 풀에 있는 서버 프로세스들을 돌려씀)
- 리스너는 서버 프로세스의 생성이 끝나면 소켓을 서버 프로세스에 인계한다. 인계 후에는 서버 프로세스와 오라클 클라이언트가 직접 송수신하므로 리스너는 자유로워짐
  - -> **병렬 처리를 가능케 하고 높은 처리량을 실현한다**

### 리스너 정지나 상태 확인
- **리스너 정지**는 명령어 lsnrctl를 이용해서 정지
- **리스너 상태**는 명령어 lsnrctl의 status를 이용해서 현재 리스너 가동 상태나 listen하고 있는 포트 번호, 유지하고 있는 데이터베이스의 정보 등을 알 수 있다.
- 서버 프로세스는 애플리케니션에서 접속을 종료하는 처리(close, disconnect)를 하면 서버프로세스도 종료함.

# 7. 오라클의 데이터 구조
`물리 구조` : 데이터 파일 등의 OS에서 보이는 구조
  - 데이터파일, 블록 등 
  - 데이터 파일은 여러 개의 블록으로 구성

`논리 구조` : OS에서는 식별할 수 없는 오라클 내부의 구조
  - 테이블 스페이스 
    - 테이블이나 인덱스 등을 보관하기 위한 공간(용기)
    - 한 개 이상의 세그먼트를 보관할 수 있다.
  - 세그먼트 
    - 테이블이나 인덱스 등의 데이터를 보관
    - 한 개 이상의 익스텐트로 구성
  - 익스텐트
    - 주로 관리를 쉽게 하기 위한 오라클 블록의 집합
    - 여러 개의 연속된 오라클 블록으로 구성
  - 오라클 블록
    - 주로 관리를 쉽게 하기 위한 데이터의 집합
    - 블록(물리구조)로 구성됨

## (오라클) 블록
- 2KB, 4KB, 8KB와 같은 크기로 나뉜 공간
- 한 건 이상의 데이터가 보관됨  
- 오라클은 블록 안에 데이터 변경에 대비해 공간을 남겨둠
- 세그먼트 안에 공간이 모자란 상황이 오면 세그먼트에 새로운 익스텐트를 추가하고 빈 블록을 늘린다.
- 블록 안의 데이터 변경용 공간은 PCTREDD라는 파라미터로 제어
- 행은 블록에 보관되어 있음

<!-- 블록 그림 -->
<!-- ---- | ---- | ---- | ---- -->
<!-- 2 | Yujun | Engineer | Busan   -->
<!-- 1 | Gideok | Engineer | Busan  -->

## 익스텐트

- 연속된 블록의 집합
- 익스텐트로 인해 각 블록의 위치가 아닌 익스텐트의 첫 위치와 블록의 개수만으로 데이터를 관리할 수 있으며, 관리 정보도 줄일 수 있다.
- 데이터를 한 번에 읽어올 수 있으므로 테이블의 풀스캔 성능을 향상시킬 수 있음
- 데이터 파일 여러 개에 걸쳐서 존재할 수 없다. 왜냐하면 익스텐트는 연속된 블록이니까

## 세그먼트

- 테이블이나 인덱스는 세그먼트
- 많은 데이터를 보관하기 위한 구조
- 익스텐트의 집합
- `사용자용 세그먼트`와 오라클이 자동적으로 생성하는 세그먼트인 `데이터를 정렬하기 위한 세그먼트`, 과거 데이터를 보관하는 `undo 세그먼트` 등이 있다.
  - `사용자용 세그먼트` (테이블, 인덱스)

## 테이블 스페이스

- 세그먼트를 분류해서 보관하기 위한 상자
- 한 개 이상의 데이터 파일로 구성
- 오라클이 데이터베이스 관리를 위해 사용하는 테이블 스페이스와 사용자가 사용하는 테이블 스페이스 등 몇 가지 존재함.

> ### 테이블 스페이스의 집합(물리적으로 데이터 파일의 집합)과 redo log 파일, 컨트롤 파일이 모이면 하나의 데이터베이스가 됨

## ROWID

- 데이터 행의 주소
- 데이터 파일의 번호나 데이터 파일 안의 블록 번호, 블록 안에 행 번호와 같은 정보로 구성

# 8. 오라클의 대기와 락

## 락

- 다중 처리를 실현하기 위해 처리를 보호하는 것
- 락이 풀리는 시점은 `COMMIT`이나 `ROLLBACK` 할 때이다. 커밋이나 롤백을 할 때까지는 'enqueue' 대기 이벤트가 발생
- `SELECT FOR UPDATE`로 락을 걸 수 있음.  
  ```SQL
  SELECT name FROM class_table WHERE id = 1
  FOR UPDATE; <- 락이 걸림
  UPDATE class_table SET name = '새로운 값' WHERE id = 1;
  ```
- DML(데이터 조작어)는 자동으로 락을 검

## 대기

- 일반적으로 대기는 성능을 나쁘게 한다는 좋지 않은 이미지가 있지만, **실제로 대기는 '기다린다'라는 것을 표시하는 것일 뿐**
- 대기 이벤트 : 기다리고 있는 일
  - `스태츠팩(또는 AWR)`이나 `v$session_wait`(세션의 정보 확인 가능)에서 확인 가능
---
- 아이들 대기(idle wait) : 처리할 것이 없어서 쉬고 있는 대기
- 아이들이 아닌 대기
  - 이유가 있어 어쩔 수 없이 하는 대기(디스크 I/O 대기)
  - 이상 상태 등 쓸데없이 SQL을 기다리게 하는 대기
  - SQL 처리에 필요한 대기(오라클은 SQL 처리 도중에 데이터가 필요해졌을 때는 디스크에서 블록을 읽어 오며 이때 대기가 발생함)

## 락에 의한 대기

- 락을 걸었다는 것 자체만으로는 대기가 발생하지 않는다. 락이 걸려 있는 대상에 다시 락을 걸려고 했을 때 대기가 발생
- 락의 정보는 `v$lock` 뷰 등에서 확인 가능
- `v$lock`로 조회하여   
    'HELD' 컬럼에 나타나면 락을 보유하고 있는 것,  
    'REQUESTED' 컬럼에 나타나면 락을 요청하고(기다리고)있는 것,  
    'LOCK TYPE'은 락의 종류를 의미
- 자주 볼 수 있는 락은 `TX(행과 관련된 락)`, `TM(테이블에 거는 락)`이다.
- `MR`락은 인스턴스가 기동하면 자동으로 얻어지는 것이라 신경 안써도 됨
- `모드` : 동시성 제어를 위한 것으로 락이 어떤 형태로 걸려 있는지 표시.
  - 모드를 잘 활용하면 필요한 상호 배제를 구현하면서 동시성을 실현할 수 있다.
- 대기의 개선 방법
  - 대기하고 있는 원인을 제거
  - 락을 획득하는 횟수를 줄여 전체 시간을 줄이는 형태

## 데드락

- 서로가 상대방이 보유하고 있는 락을 기다리느라 영원히 처리를 진행할 수 없는 상태
- 데드락 (ORA-00060) 일 때는 오라클에 의해 자동으로 한쪽의 처리가 롤백되며, alert 파일과 트레이스 파일에 정보가 표시
- `데드락 그래프`에 데드락의 정보가 기록되며 `v$lock`으로 확인 가능

## 래치의 구조

- 래치(latch)
  - 다중 처리를 구현하기 위한 락
  - 메모리나 데이터를 조작할 때 상호 배타적(mutual exclusive)으로 처리하지 않으면 데이터가 손상될 수 있는 경우를 보호하고자 사용
  - 일반적인 락과 다른 부분 오라클 내부에서 자동으로 얻으며 SQL을 한 번 실행하기 위해서는 여러 래치를 얻고 해제하기를 반복
  - 스태츠팩(또는 AWR)을 보면 수십개에서 수백개가 존재하는데 이유는 '병렬 처리를 가능케 하고 높은 처리량을 실현'하기 위해서이다.
  - 시스템이 대규모가 아닐 때 래치 경합이 심하다면 CPU 자원이 부족하거나 페이징 등 바람직하지 않은 상태인지를 확인

  

> *어렵다*
  
# 9. 리두와 언두의 동작

## 지속성을 구현하기 위해서

- 데이터베이스에서 중요한 특징인 지속성은 '**커밋한 데이터를 지키는 특성**'이다. 구현 방법으로는 커밋한 데이터를 그 즉시 디스크에 기록하면 될 것 같지만 디스크의 특성으로 I/O의 시간 대부분은 트랙을 찾는 시간이 차지하고 있다. 이 방법으로 대량의 데이터를 변경하면 커밋하는데 시간이 오래걸린다.  
- 그래서 RDBMS 대부분은 **로그**를 채용해 성능과 지속성을 양립시킬 수 있게 함. 
- 오라클은 리두 로그에 의해 성능과 지속성을 확보
  ->리두 로그에 데이터를 정리해서 집어넣은 후 기록하는 것으로 I/O의 횟수가 줄어들며 순차적으로 접근하기 때문이다. I/O 크기가 커지더라도 트랙을 찾는 작업의 횟수는 변하지 않으므로 그만큼 I/O 시간이 지연되지 않는다.

> - **리두 로그** : 누군가가 무엇을 했다는 정보
> - **언두 정보** : 어떻게 하면 과거의 상태로 돌아갈 수 있는지에 관한 정보
> - **롤 포워드** : 리두 로그를 사용해서 과거의 데이터를 최신 데이터 쪽으로 흐르게 하는 것
> - **롤백** : 언두의 정보를 사용해서 변경을 취소(과거의 상태로 되돌림)하는 것
> - **SCN(System Change Number)** : 오라클 내부의 시간(정확히는 시간 대신에 번호)을 나타낸다. 복구 등에 사용됨

## 리두의 아키텍쳐

- 데이터의 변경은 캐시 위에서 이루어짐
- 이때 리두 로그(변경 이력 데이터)라고 불리는 로그 데이터가 생성됨
- 리두 로그와 언두를 서버 프로세스가 생성함
- 이 시점(커밋되지 않은 시점)에 블록의 데이터가 변경됨
- 오라클은 리두 로그를 커밋하기 전까지 디스크에 기록하는 것으로 지속성을 구현

### 리두 로그의 아키텍쳐
- 서버 프로세스가 리두 로그 버퍼에 리두 로그를 넣는다.
- 리두 로그용 메모리로서 리두 로그 버퍼가 공유 메모리에 존재함
- **LGWR 프로세스** : 리두 로그를 디스크에 기록함 (서버프로세스에서 의뢰를 받거나 자발적으로 리두 로그를 리두 로그 버퍼에서 리두 로그 파일에 기록)
- **리두 로그 파일** : 리두 로그를 보관한다. 그리고 개수가 한정(일반적으로 한 세트에 3개)되어 있고 크기에도 제한이 있으므로 계속 보관하기 힘듬. 일시적인 리두 로그의 보관 창고
- **아카이브 리두 로그 파일** : 오랫동안 리두 로그를 보관해 두기 위한 파일. 오랜 시간 보관할 수 있는 본격적인 보관 창고
- **ARCH 프로세스** : 리두 로그 파일을 아카이브 리두 로그 파일에 옮기는 역할

#### 리두 로그 파일은 매우 중요한 파일이므로 반드시 다중화해야함
- 일반적으로 리두 로그 그룹을 여러 개의 세트로 만들어 다중화하지만, 리두 로그 파일의 다중화는 **멤버를 추가하는 것으로 수행**.
- 멤버가 여러개 있다면 LGWR은 모든 멤버에 기록하기 때문에 다중화됨
- 동작 순서 : **서버 프로세스는 커밋했을 때 LGWR에 리두 로그를 기록하도록 의뢰한다. 의로를 받은 LGWR은 리두 로그를 리두 로그 파일에 기록을 하고 끝이나면 LGWR가 서버 프로세스에 기록이 끝났다고 통보한다. 그 후에 서버 프로세스는 커밋이 끝난 것을 오라클 클라이언트에게 통보함**
- 스태츠팩(또는 AWR)이나 v$session_wait 등에서 자주 볼 수 있는 'log file sync'라는 대기 이벤트는 주로 **LGWR이 리두 로그를 기록하는 것을 기다리고 있는것**이다.
- 리두 로그에 관련한 처리는 래치가 보호하고 있음 ('redo copy', 'redo allocation' 등으로 표시)

---
- **스토리지의 write 캐시**는 기록하는 I/O를 위한 캐시이다. 일반적으로 오라클의 write는 디스크에 기록되기 전까지는 I/O가 끝나지 않지만, write 캐시가 있다면 write 캐시에 기록하는 것으로 I/O가 끝난다. 따라서 기록하는 I/O의 응답 시간이 빨라짐

## 언두의 아키텍쳐
- 수동 언두, 자동 언두가 존재. 아래의 내용은 자동 언두로 설명
- 데이터가 변경되면 언두 정보가 생성됨 (언두 정보는 **세그먼트**에 보관되는데 이 뜻은 어딘가의 **테이블 스페이스**에 보관되어있다는 뜻이다. `언두 테이블 스페이스`라고 부름))
- `언두 테이블 스페이스`에는 **트랜잭션**과 **언두 세그먼트**가 일대일로 대응하기 떄문에 여러 개의 **언두 세그먼트**가 생성된다.
- `언두 세그먼트`는 **링 버퍼**이다. **링 버퍼**는 조금 지나면 데이터가 덮어씌워지는 버퍼이지만, 커밋하지 않은 데이터는 덮어써지지 않는다. 덮어쓰고 싶지 않을 때는 `언두 세그먼트`의 크기를 크게한다.
- `언두 세그먼트`는 일정 기간 데이터를 보관하면 한 바퀴 돈 후 이전 데이터를 덮어쓴다. (링 모양임)
- undo_retention 파라미터로 언두 정보의 유지 시간을 설정할 수 있따. <u>커밋을 했더라도 일정 시간 언두 정보를 유지하고 싶을 때 사용</u>한다.

## 여러 상황에서의 리두와 언두의 동작

### 롤백할 때의 동작
- 오라클에서는 커밋하지 않았더라도 데이터는 이미 변경된 상태
- 롤백이 수행되면 **언두 정보**를 사용하여 데이터를 원래의 값으로 돌려놓음
- **`PMON` (백그라운드 프로세스) : 서버 프로세스가 비정상적으로 종료했을때도 정기적으로 체크를 수행하며 서버 프로세스의 뒤처리를 수행한다.**
- **`SMON` (백그라운드 프로세스) : 데이터를 트랜잭션 시작 전의 상태로 돌줌**

### 읽기 일관성에 동반되는 동작
- 데이터를 검색할 때 어떤 시점의 데이터를 보여 주는 기능
- ex) 검색을 시작한 후에 다른 세션에서 변경한 데이터를 읽지 못하게 하고, 검색을 시작한 시점의 데이터를 보여주는 것
- 즉 데이터가 변경된 시점을 확인하고, 작업이 시작한 후에 변경된 데이터일 때는 **언두 정보**를 사용해서 과거의 데이터를 띄워줌

### 커밋되지 않은 데이터를 읽어 올 때의 동작
- 오라클은 고립성을 지키기 위해 'read committed' 동작을 하는데 이는 '다른 세션의 커밋한 변경 데이터는 읽을 수 있다'는 특징을 가지고 있지만 커밋 되지 않은 변경 데이터를 읽어 올 수는 없다. 그래서 'read committed' 동작이 필요할 때 **읽기 일관성**과 마찬가지로 언두를 사용해서 변경되기 이전의 데이터를 보여준다

### 체크포인트의 동작
- 체크포인트는 메모리의 데이터를 디스크와 동기화하는 작업 (DBWR이 메모리에서 디스크로 데이터를 기록)
- 리두 로그와 예전 데이터가 있으면 롤 포워드를 할 수 있지만 너무 오래된 데이터일 경우 롤 포워드하려고 하면 시간이 오래 걸린다. 그래서 체크포인트를 이용해서 정기적으로 데이터를 디스크에 기록하고 롤 포워드에 걸리는 시간을 줄일 수 있다. 
- 체크포인트는 파라미터로 제어할 수 있는데 너무 자주 기록을 하면 병목 현상이 발생해서 성능이 안좋아질 수 있다.

# 10. 백업/복구의 아키텍처와 동작
## 백업의 종류와 특징
- 콜드 백업
  - 인스턴스를 완전히 정지한 상태에서 받는 백업
  - 모든 데이터가 파일에 기록된(체크포인트 완료)상태이기 때문에 할 수 있다면 콜드 백업을 받는 편이 간단

- 온라인 백업(핫 백업)
  - 24시간 데이터베이스를 운영하는 상황에서 백업 (운영하는 상태에서 받는 것이므로 체크포인트된 상태의 파일이 아님)
  - `BEGIN BACKUP`으로 백업을 시작하고 끝나면 `END BACKUP` 실행 (오라클의 백업관리자인 RMAN 으로 백업할 경우는 안해도 됨)
  - `BEGIN BACKUP`과 `END BACKUP`사이에 변경이 일어난 데이터 블록을 리두 로그에 기록하여 나중에 복구 시에 문제가 없어록 해야함

## 기본적인 복구의 종류와 동작
### 장애(인스턴스) 복구와 미디어 복구
- 장애 복구
  - 인스턴스가 비정상 종료된 후 다시 기동할 때 자동으로 수행하는 복구
- 미디어 복구
  - 디스크의 데이터가 손상되었을 때 사용자가 명시적으로 실행하는 복구
  - 일반적으로 이야기하는 복구

### 완전 복구와 불완전 복구의 차이
- 완전 복구
  - 최신 데이터까지 복구
  - 특별히 지정하지 않으면 완전 복구를 실행
- 불완전 복구
  - 어떤 시점까지만 복구
  - 아카이브 리두 로그가 유실되었을 때, 어떤 사정으로 인해 어떤 시점의 데이터로 바꾸고 싶을 때 

### 데이터베이스 / 테이블 스페이스 / 데이터 파일 / 블록의 복구
- 데이터베이스 복구
  - 데이터베이스 전체를 복구
  - `RECOVER DATABASE`
- 테이블 스페이스 복구
  - 운영을 하면서 손상된 테이블 스페이스만을 복구하고 싶을 때 사용할 수 없는 상태(오프라인)으로 변경하고 테이블 스페이스를 복구
- 데이터 파일 복구
  - `RECOVER DATAFILE [데이터 파일명]` 
- 블록 복구
  - RMAN을 사용하면 특정 블록을 지정해서 복구할 수 있음
  - 특정 블록만을 백업된 데이터로 돌려놓고 해당 블록에 관한 리두 로그만을 사용하는 고급 복구
  > *RMAN(Recovery Manager) : 백업/복구를 간단하게 수행할 수 있는 관리도구*
- 복구를 할 때는 가용성, 복구에 걸리는 시간, 재작업할 가능성을 중요시 해야함

### 복구가 필요없는 테이블 스페이스
- 임시 테이블 스페이스
- 읽기 전용 테이블 스페이스
- 인덱스용 테이블 스페이스

### 기본적인 복구의 흐름(데이터베이스 전체의 복구)
- 데이터베이스 전체를 복구할 때는 모든 데이터 파일을 리스토어하고 업무를 정지한 후 복구  

1. 데이터베이스가 손상되었는지를 확인
   - 오라클은 가동 중에 손상되었는지를 알 수도 있고, 기동하기 전, 사용자나 스토리지가 알아챌 때도 있다.
2. 재작업을할 수 있도록 현재 상태를 백업
3. 필요한 데이터 파일과 아카이브 리두 로그 파일을 리스토어함
4. 복구를 실행

> 10장 다시보기

# 11. 백그라운드 프로세스의 동작과 역할
## 백그라운드 프로세스의 동작
1. 서버 프로세스는 일이 도착하기 전까지 'SQL Net message from client'를 띄우며 대기하며 OS상에서 슬립 상태
2. 서버 프로세스가 메시지(SQL 등)를 받으면 깨어나서 처리
3. 서버 프로세스가 백그라운드 프로세스에 의뢰해야 할 일이 생기면 의뢰 후 '끝나면 깨워줘'라고 한 후 다시 슬립상태
4. 백그라운드 프로세스도 마찬가지로 슬립상태에 있다가 처리를 한 후 서버 프로세스를 깨우고 자신도 다시 슬립상태
- 기본적으로 모든 프로세스는 잠들어 있는 상태(슬립 상태)이며 업무가 도착하면 깨어나고 없으면 다시 잠드는 형태로 동작
  - 슬립 상태에서는 CPU를 소비하지 않음. -> 프로세스의 수는 크게 중요하지 않다

## 슬립과 대기의 관계
- `SQL Net message from client`
  - 오라클 클라이언트에서 통신(메시지)을 기다리고 있는 상태(READ 대기), OS상에서 슬립
- `db file sequential(scattered) read`
  - 디스크에서 읽어 오는 대기 이벤트, OS상에서 슬립
- `아이들 대기 이벤트`
  - SQL의 처리와는 관계없는 대기 이벤트

#### `v$session_wait`로 아이들 대기 이벤트로 얼마나 슬립하고 있었는지 알 수 있음

## 백그라운드 프로세스
- DBWR
  - 이미 변경된 데이터를 캐시에서 디스크로 기록하는 역할(커밋한 시점에 기록X. 천천히 수행)
- LGWR
  - 커밋한 시점의 리두 로그를 디스크에 기록(리두 로그 파일에 리두 로그를 기록)
- ARCH
  - 아카이브 리두 로그 파일에 기록

### DBWR(DBW)의 동작과 역할
- DBMS에서 비동기 I/O를 사용하면 여러 개의 I/O를 처리할 수 있기 때문에 디스크를 놀게 하지 않아도 된다.(I/O병목 현상 해결) 
- 비동기 I/O라 할지라도 SQL의 속도가 느려질 수 있으므로 디스크에 너무 많은 부하를 주러선 안되는데 이럴때 `DBWR(DBW)`은 부하가 너무 집중되지 않게 하기 위해 긴 시간에 걸쳐 가능한 한 균일하게 부하를 줄 수 있도록 동작  
  -> '(SQL의) 응답을 중시한다'를 지키기 위해 만들어진 좋은 구조
- `rdbms ipc message`
  - '아이들 상태'
- `db file parallel write`
  - '동시에 병렬로 데이터를 디스크에 기록하고 있다.'
- `DBW0`, `DBW1`, `DBW2` 이런 것들은 `DBWR`이 여러개 기동하고 있다는 뜻
- 대규모 시스템이나 디스크에 기록하는 속도가 느린 환경에서 여러 개를 기동하면 성능 향상
- 비동기 I/O를 사용할 수 없는 환경에서 효과적
- `DBWR`의 수는 초기화 파라미터 `DB_WRITER_PROCESSES`에서 조정 가능

### LGWR의 동작과 역할
- `LGWR`은 `rdbms ipc message` 상태로 슬립
- `LGWR`은 커밋했을 때 리두 로그를 기록
- 커밋을 하지 않았어도 3초에 한 번 `rdbms ipc message`에서 깨어나서 로그 버퍼의 데이터를 기록
- 기록할 때 `LGWR`은 `log file parallel write` 상태로 대기 -> 가능한 한 병렬로 수행하려 기록
- 서버 프로세스가 `LGWR`이 리두 로그를 기록하는 것을 기다릴 때는 `log file sync` 대기 이벤트

### PMON의 동작과 역할
- 메모리와 프로세스 전문 청소 업체
- 서버 프로세스가 비정상 종료했을 때 메모리나 프로세스를 정리 -> 이 작업을 하지 않으면 서버 프로세스 한 개가 중지되었을 때 인스턴스 전체가 중지될 위험이 있음
- 필요 시 약 1분에 한 번 청소를 수행
- `pmon timer` 대기 이벤트 상태로 슬립
- `listener.ora` 파일에 인스턴스의 정보가 기재되어 있지 않을 때 `PMON`이 `동적 등록(dynamic registration` 함

### SMON의 동작과 역할
- 공간 정문 청소 업체
  > 딕셔너리 관리 테이블스테이스를 사용할 경우 테이블 스페이스 안의 빈 공간들을 합친다든가, 처리 도중에 종료된 트랜잭션을 롤백한다던가, 임시 세그먼트를 청소하거나 함
- 평소 `smon timer` 대기 이벤트 상태로 슬립

### ARCH의 동작과 역할
- 최근 오라클에서는 `ARCX` (`ARC1`, `ARC2`, `ARC3`)
- 아카이버 프로세스는 리두 로그 파일을 아카이브하는 프로세스
- 보관된 리두 로그 파일은 아칼이브 리두 로그 파일
- `rdbms ipc message` 대기 이벤트 상태로 슬립하고 있지만 로그 스위치(`LGWR`이 내려 쓸 리두 로그 파일을 전환하는 작업)가 수행되어 아카이브를 생성할 필요가 있을 때 작업
